package com.dataintuitive.viash

import functionality._
import dataobjects.{FileObject, Output}
import platforms._
import resources.{BashScript, Script}

import sys.process.{Process, ProcessLogger}
import java.io.{ByteArrayOutputStream, File, FileWriter, PrintWriter}
import java.nio.file.Paths

import com.dataintuitive.viash.config.Config
import helpers.IO

object ViashTest {
  case class TestOutput(name: String, exitValue: Int, output: String)

  def apply(config: Config, verbose: Boolean, keepFiles: Boolean) {
    val fun = config.functionality
    val plat = config.platform.get

    // create temporary directory
    val dir = IO.makeTemp("viash_test_" + fun.name)
    if (verbose) println(s"Running tests in temporary directory: '$dir'")

    // run tests
    val results = ViashTest.runTests(fun, plat, dir, verbose = verbose)
    val count = results.count(_.exitValue == 0)
    val anyErrors = count < results.length

    // print results of tests with errors. if verbose, they were printed already.
    for (res ← results if res.exitValue > 0 && !verbose) {
      println(s">> ${res.name} finished with code ${res.exitValue}:")
      println(res.output)
      println()
    }

    if (verbose) {
      if (results.isEmpty) {
        println(s"WARNING! No tests found!")
      } else if (anyErrors) {
        println(s"ERROR! Only $count out of ${results.length} test scripts succeeded!")
      } else {
        println(s"SUCCESS! All $count out of ${results.length} test scripts succeeded!")
      }
    }

    if (!keepFiles && !anyErrors) {
      if (verbose) println("Cleaning up temporary directory")
      IO.deleteRecursively(dir)
    }

    if (anyErrors) {
      throw new RuntimeException(s"Only $count out of ${results.length} test scripts succeeded!")
    }
  }

  def runTests(fun: Functionality, platform: Platform, dir: File, verbose: Boolean = false): List[TestOutput] = {
    // build regular executable
    val buildFun = platform.modifyFunctionality(fun)
    val buildDir = Paths.get(dir.toString, "build_executable").toFile
    buildDir.mkdir()
    IO.writeResources(buildFun.resources.getOrElse(Nil), buildDir)

    // run command, collect output
    val stream = new ByteArrayOutputStream
    val printWriter = new PrintWriter(stream)
    val logWriter = new FileWriter(Paths.get(buildDir.toString, "_viash_build_log.txt").toString, true)

    val logger: String => Unit =
      (s: String) => {
        if (verbose) println(s)
        printWriter.println(s)
        logWriter.append(s + sys.props("line.separator"))
      }

    // run command, collect output
    val buildResult =
      try {
        val executable = Paths.get(buildDir.toString, fun.name).toString
        logger(s"+$executable ---setup")
        val exitValue = Process(Seq(executable, "---setup"), cwd = buildDir).!(ProcessLogger(logger, logger))

        TestOutput("build_executable", exitValue, stream.toString)
      } finally {
        printWriter.close()
        logWriter.close()
      }

    // generate executable for native platform
    val exe = NativePlatform(version = None).modifyFunctionality(fun).resources.get.head

    // fetch tests
    val tests = fun.tests.getOrElse(Nil)

    val testResults = tests.filter(_.isInstanceOf[Script]).map { file =>
      val test = file.asInstanceOf[Script]

      val dirArg = FileObject(
        name = "dir",
        direction = Output,
        default = Some(dir)
      )
      // generate bash script for test
      val funonlytest = platform.modifyFunctionality(fun.copy(
        arguments = Nil,
        dummy_arguments = Some(List(dirArg)),
        resources = Some(List(test)),
        set_wd_to_resources_dir = Some(true)))
      val testbash = BashScript(
        name = Some(test.filename),
        text = funonlytest.resources.getOrElse(Nil).head.text
      )

      // assemble full resources list for test
      val funfinal = fun.copy(resources = Some(
        testbash :: // the test, wrapped in a bash script
          exe :: // the executable, wrapped with a native platform,
          // to be run inside of the platform of the test
          funonlytest.resources.getOrElse(Nil).tail ::: // other resources generated by wrapping the test script
          fun.resources.getOrElse(Nil).tail ::: // other resources provided in fun.resources
          tests.filter(!_.isInstanceOf[Script]) // other resources provided in fun.tests
      ))

      // make a new directory
      val newdir = Paths.get(dir.toString, "test_" + test.filename).toFile
      newdir.mkdir()

      // write resources to dir
      IO.writeResources(funfinal.resources.getOrElse(Nil), newdir)

      // run command, collect output
      val stream = new ByteArrayOutputStream
      val printwriter = new PrintWriter(stream)
      val logwriter = new FileWriter(Paths.get(newdir.toString, "_viash_test_log.txt").toString, true)

      val logger: String => Unit =
        (s: String) => {
          if (verbose) println(s)
          printwriter.println(s)
          logwriter.append(s + sys.props("line.separator"))
        }

      // run command, collect output
      try {
        val executable = Paths.get(newdir.toString, testbash.filename).toString
        val exitValue = Process(Seq(executable), cwd = newdir).!(ProcessLogger(logger, logger))

        TestOutput(test.filename, exitValue, stream.toString)
      } finally {
        printwriter.close()
        logwriter.close()
      }
    }

    buildResult :: testResults
  }
}
