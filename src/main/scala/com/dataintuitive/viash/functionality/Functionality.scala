package com.dataintuitive.viash.functionality

import scala.io.Source
import io.circe.yaml.parser
import java.nio.file.Paths
import java.io.File
import dataobjects._
import resources._

case class Functionality(
  name: String,
  resources: List[Resource],
  description: Option[String] = None,
  function_type: Option[FunctionType] = None,
  arguments: List[DataObject[_]] = Nil,
  tests: Option[List[Resource]] = None,
  private var _rootDir: Option[File] = None // :/
) {

  require(resources.length > 0, message = "resources should contain at least resource")
//  require(resources.head.isInstanceOf[Script], message = "first resource should be of type bash_script, r_script, python_script, or executable")

  def mainScript: Option[Script] =
    resources.head match {
      case s: Script => Some(s)
      case _ => None
    }

  def rootDir = {
    _rootDir match {
      case Some(f) => f
      case None => throw new RuntimeException("root directory of functionality object has not been defined yet")
    }
  }
  def rootDir_= (newValue: File) = {
    _rootDir =
      if (newValue.isFile()) {
        Some(newValue.getParentFile())
      } else {
        Some(newValue)
      }
  }

  def readCode(script: Option[Script]): Option[String] = {
    script match {
      case None => None
      case Some(_: Executable) => None
      case Some(s) if s.text.isDefined => s.text
      case Some(s) => {
        val mainPath = Paths.get(rootDir.getPath(), s.path.get).toFile()
        Some(Source.fromFile(mainPath).mkString(""))
      }
    }
  }

  def readCodeWithArgParse(script: Option[Script]): Option[String] = {
    readCode(script).map(code => {
      val lines = code.split("\n")

      val startIndex = lines.indexWhere(_.contains("VIASH START"))
      val endIndex = lines.indexWhere(_.contains("VIASH END"))

      if (startIndex >= 0 && endIndex >= 0) {
        val li =
          lines.slice(0, startIndex + 1) ++
          Array(
            mainScript.get.commentStr + " The following code has been auto-generated by Viash.",
            mainScript.get.generateArgparse(this)
          ) ++
          lines.slice(endIndex, lines.length)

        li.mkString("\n")
      } else {
        code
      }
    })
  }

  def mainCode = readCode(mainScript)
  def mainCodeWithArgParse = readCodeWithArgParse(mainScript)
}

object Functionality {
  def parse(file: java.io.File): Functionality = {
    val str = Source.fromFile(file).mkString
    val fun = parser.parse(str)
      .fold(throw _, _.as[Functionality])
      .fold(throw _, identity)

    // save root directory of Functionality object
    fun.rootDir = file
    fun
  }
}

sealed trait FunctionType
case object AsIs extends FunctionType
case object Convert extends FunctionType
case object ToDir extends FunctionType
case object Join extends FunctionType
